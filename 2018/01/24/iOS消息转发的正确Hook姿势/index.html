<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "a56087b5"
    });
  daovoice('update');
  </script>




  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JSPatch,Aspects," />










<meta name="description" content="前言有很多iOS开源项目通过hook第三层转发forwardInvocation，去实现各种各样的黑魔法。如果一个项目工程同时接入了多个这样的库，那么在享受这些库给我们带来便利的同时，也有可能会遭受这些库带来的各种各样的坑。 iOS的消息转发机制iOS的消息转发机制已经被讲的烂大街了，这里不再赘述，直接画重点，OC方法调用主要遵循以下调用流程：   1、先查找类的方法缓存，如果能找到，跳到done">
<meta name="keywords" content="JSPatch,Aspects">
<meta property="og:type" content="article">
<meta property="og:title" content="JSPatch VS Aspects">
<meta property="og:url" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/index.html">
<meta property="og:site_name" content="凌云的博客">
<meta property="og:description" content="前言有很多iOS开源项目通过hook第三层转发forwardInvocation，去实现各种各样的黑魔法。如果一个项目工程同时接入了多个这样的库，那么在享受这些库给我们带来便利的同时，也有可能会遭受这些库带来的各种各样的坑。 iOS的消息转发机制iOS的消息转发机制已经被讲的烂大街了，这里不再赘述，直接画重点，OC方法调用主要遵循以下调用流程：   1、先查找类的方法缓存，如果能找到，跳到done">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/10.png">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/11.png">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/02.png">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/03.png">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/04.png">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/05.png">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/06.png">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/06.png">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/07.png">
<meta property="og:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/08.png">
<meta property="og:updated_time" content="2018-05-30T14:27:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JSPatch VS Aspects">
<meta name="twitter:description" content="前言有很多iOS开源项目通过hook第三层转发forwardInvocation，去实现各种各样的黑魔法。如果一个项目工程同时接入了多个这样的库，那么在享受这些库给我们带来便利的同时，也有可能会遭受这些库带来的各种各样的坑。 iOS的消息转发机制iOS的消息转发机制已经被讲的烂大街了，这里不再赘述，直接画重点，OC方法调用主要遵循以下调用流程：   1、先查找类的方法缓存，如果能找到，跳到done">
<meta name="twitter:image" content="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/10.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/"/>





  <title>JSPatch VS Aspects | 凌云的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">凌云的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lingyun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凌云的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JSPatch VS Aspects</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-24T22:03:46+08:00">
                2018-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,309
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有很多iOS开源项目通过hook第三层转发forwardInvocation，去实现各种各样的黑魔法。如果一个项目工程同时接入了多个这样的库，那么在享受这些库给我们带来便利的同时，也有可能会遭受这些库带来的各种各样的坑。</p>
<h2 id="iOS的消息转发机制"><a href="#iOS的消息转发机制" class="headerlink" title="iOS的消息转发机制"></a>iOS的消息转发机制</h2><p>iOS的消息转发机制已经被讲的烂大街了，这里不再赘述，直接画重点，OC方法调用主要遵循以下调用流程：</p>
<blockquote>
<ul>
<li>1、先查找类的方法缓存，如果能找到，跳到done；</li>
<li>2、重新查找类的方法缓存，如果能找到，跳到done；</li>
<li>3、依次遍历类的方法列表，如果能找到，将查找的方法添加到缓存，跳到done；</li>
<li>4、循环遍历该类的父类，直到<code>NSObject</code>，对其中的每一层父类依次执行3和4的操作；</li>
<li>5、如果当前类和其父类链中均没有找到，进入方法决议，如果决议成功，跳转retry；</li>
<li>6、如果方法决议未实现，runtime就会询问当前的接受者是否有其他对象可以处理这个未知的selector，方法是<code>forwardingTargetForSelector:</code></li>
<li>7、如果没有备援接收者，那么进行消息重定向。这个时候runtime会将未知消息的所有细节都封装为NSInvocation对象，调用<code>forwardInvocation:</code></li>
</ul>
</blockquote>
<h2 id="iOS消息转发机制的Hook原理"><a href="#iOS消息转发机制的Hook原理" class="headerlink" title="iOS消息转发机制的Hook原理"></a>iOS消息转发机制的Hook原理</h2><p>根据上面的消息转发机制：当调用一个OC对象的方法时，会沿着继承链层层往上寻找，直到寻找到NSObject，如果还没有寻找到，说明这个方法不存在，但是并不会马上抛出异常，而是会经过多层转发，层层调用对象的<code>-resolveInstanceMethod:</code>, <code>-forwardingTargetForSelector:</code>, <code>-methodSignatureForSelector:</code>, <code>-forwardInvocation:</code> 等方法。其中最后 <code>-forwardInvocation:</code> 是会有一个 NSInvocation 对象，这个 NSInvocation 对象保存了这个方法调用的所有信息，包括 Selector 名，参数和返回值类型，最重要的是有所有参数值，可以从这个 NSInvocation 对象里拿到调用的所有参数值。<br><strong>如果我们想实现一个库，来动态修改某些方法的实现，那么就可以利用hook<code>forwardInvocation</code>来实现：自定义一个自己的forwardInvocation处理函数，把要修改的方法的调用统统都通过转发到这个处理函数里面，然后就可以动态控制这些方法的下一步的具体走向了</strong>。</p>
<h3 id="（1）JSPatch的Hook原理"><a href="#（1）JSPatch的Hook原理" class="headerlink" title="（1）JSPatch的Hook原理"></a>（1）JSPatch的Hook原理</h3><p>先来看下JSPatch是如何来实现的，在JSPatch.mm文件中可以看到overrideMethod的定义<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> overrideMethod(Class cls, <span class="built_in">NSString</span> *selectorName, JSValue *function, <span class="built_in">BOOL</span> isClassMethod, <span class="keyword">const</span> <span class="keyword">char</span> *typeDescription)</span><br><span class="line">&#123;</span><br><span class="line">    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!typeDescription) &#123;</span><br><span class="line">        Method method = class_getInstanceMethod(cls, selector);</span><br><span class="line">        typeDescription = (<span class="keyword">char</span> *)method_getTypeEncoding(method);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    IMP originalImp = class_respondsToSelector(cls, selector) ? class_getMethodImplementation(cls, selector) : <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line">    <span class="meta">#if !defined(__arm64__)</span></span><br><span class="line">        <span class="keyword">if</span> (typeDescription[<span class="number">0</span>] == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">            <span class="built_in">NSMethodSignature</span> *methodSignature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:typeDescription];</span><br><span class="line">            <span class="keyword">if</span> ([methodSignature.debugDescription rangeOfString:<span class="string">@"is special struct return? YES"</span>].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">                msgForwardIMP = (IMP)_objc_msgForward_stret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wundeclared-selector"</span></span></span><br><span class="line">    <span class="keyword">if</span> (class_getMethodImplementation(cls, <span class="keyword">@selector</span>(forwardInvocation:)) != (IMP)JPForwardInvocation) &#123;</span><br><span class="line">        IMP originalForwardImp = class_replaceMethod(cls, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)JPForwardInvocation, <span class="string">"v@:@"</span>);</span><br><span class="line">        <span class="keyword">if</span> (originalForwardImp) &#123;</span><br><span class="line">            class_addMethod(cls, <span class="keyword">@selector</span>(ORIGforwardInvocation:), originalForwardImp, <span class="string">"v@:@"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">    [cls jp_fixMethodSignature];</span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(cls, selector)) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *originalSelectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"ORIG%@"</span>, selectorName];</span><br><span class="line">        SEL originalSelector = <span class="built_in">NSSelectorFromString</span>(originalSelectorName);</span><br><span class="line">        <span class="keyword">if</span>(!class_respondsToSelector(cls, originalSelector)) &#123;</span><br><span class="line">            class_addMethod(cls, originalSelector, originalImp, typeDescription);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *JPSelectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"_JP%@"</span>, selectorName];</span><br><span class="line">    </span><br><span class="line">    _initJPOverideMethods(cls);</span><br><span class="line">    _JSOverideMethods[cls][JPSelectorName] = function;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Replace the original secltor at last, preventing threading issus when</span></span><br><span class="line">    <span class="comment">// the selector get called during the execution of `overrideMethod`</span></span><br><span class="line">    class_replaceMethod(cls, selector, msgForwardIMP, typeDescription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JSPatch的Hook过程如下：</p>
<blockquote>
<ul>
<li>1、将<code>SEL(forwardInvocation)</code>指向JSPatch的自定义转发过程<code>IMP(JPForwardInvocation)</code>，同时再定义一个<code>SEL(ORIGforwardInvocation)</code>，指向原来的<code>IMP(forwardInvocation)</code>，处理原有转发。注意：对于<code>JSPatch</code>的每个类，尽管<code>overrideMethod</code>会被调用多次，但是这个步骤对于每个类只调用1次。</li>
</ul>
<ul>
<li>2、将<code>SEL(methodName)</code>指向<code>_objc_msgForward</code>(<code>_objc_msgForward_stret</code>)，同时再定义一个<code>SEL(ORIGmethodName)</code>指向方法原来的实现`IMP(methodName)``</li>
<li>3、将替换的方法JS代码块以<code>_JSOverideMethods[cls][JPSelectorName] = function</code>的形式保存下来</li>
</ul>
</blockquote>
<p>接下来再看下<code>JPForwardInvocation</code>的处理过程<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> JPForwardInvocation(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> assignSlf, SEL selector, <span class="built_in">NSInvocation</span> *invocation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> deallocFlag = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">id</span> slf = assignSlf;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature = [invocation methodSignature];</span><br><span class="line">    <span class="built_in">NSInteger</span> numberOfArguments = [methodSignature numberOfArguments];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(invocation.selector);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *JPSelectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"_JP%@"</span>, selectorName];</span><br><span class="line">    JSValue *jsFunc = getJSFunctionInObjectHierachy(slf, JPSelectorName);</span><br><span class="line">    <span class="keyword">if</span> (!jsFunc) &#123;</span><br><span class="line">        IMP invocationIMP = class_getMethodImplementation([slf <span class="keyword">class</span>], invocation.selector);        </span><br><span class="line">        JPExecuteORIGForwardInvocation(slf, selector, invocation);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 参数解析（在此不贴代码了）</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行JS代码片段，并进行返回值解析(贴一个最简单的JS代码块的执行，实际上很复杂)</span></span><br><span class="line">    <span class="meta">#define JP_FWD_RET_CALL_JS \</span></span><br><span class="line">            JSValue *jsval; \</span><br><span class="line">            [_JSMethodForwardCallLock lock];   \</span><br><span class="line">            jsval = [jsFunc callWithArguments:params]; \</span><br><span class="line">            [_JSMethodForwardCallLock unlock]; \</span><br><span class="line">            <span class="keyword">while</span> (![jsval isNull] &amp;&amp; ![jsval isUndefined] &amp;&amp; [jsval hasProperty:<span class="string">@"__isPerformInOC"</span>]) &#123; \</span><br><span class="line">                <span class="built_in">NSArray</span> *args = <span class="literal">nil</span>;  \</span><br><span class="line">                JSValue *cb = jsval[<span class="string">@"cb"</span>]; \</span><br><span class="line">                <span class="keyword">if</span> ([jsval hasProperty:<span class="string">@"sel"</span>]) &#123;   \</span><br><span class="line">                    <span class="keyword">id</span> callRet = callSelector(![jsval[<span class="string">@"clsName"</span>] isUndefined] ? [jsval[<span class="string">@"clsName"</span>] toString] : <span class="literal">nil</span>, [jsval[<span class="string">@"sel"</span>] toString], jsval[<span class="string">@"args"</span>], ![jsval[<span class="string">@"obj"</span>] isUndefined] ? jsval[<span class="string">@"obj"</span>] : <span class="literal">nil</span>, <span class="literal">NO</span>);  \</span><br><span class="line">                    args = @[[_context[<span class="string">@"_formatOCToJS"</span>] callWithArguments:callRet ? @[callRet] : _formatOCToJSList(@[_nilObj])]];  \</span><br><span class="line">                &#125;   \</span><br><span class="line">                [_JSMethodForwardCallLock lock];    \</span><br><span class="line">                jsval = [cb callWithArguments:args];  \</span><br><span class="line">                [_JSMethodForwardCallLock unlock];  \</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>JSPatch的原有转发逻辑<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> JPExecuteORIGForwardInvocation(<span class="keyword">id</span> slf, SEL selector, <span class="built_in">NSInvocation</span> *invocation)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wundeclared-selector"</span></span></span><br><span class="line">    SEL origForwardSelector = <span class="keyword">@selector</span>(ORIGforwardInvocation:);</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([slf respondsToSelector:origForwardSelector]) &#123;</span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *methodSignature = [slf methodSignatureForSelector:origForwardSelector];</span><br><span class="line">        <span class="keyword">if</span> (!methodSignature) &#123;</span><br><span class="line">            _exceptionBlock([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"unrecognized selector -ORIGforwardInvocation: for instance %@"</span>, slf]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSInvocation</span> *forwardInv= [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSignature];</span><br><span class="line">        [forwardInv setTarget:slf];</span><br><span class="line">        [forwardInv setSelector:origForwardSelector];</span><br><span class="line">        [forwardInv setArgument:&amp;invocation atIndex:<span class="number">2</span>];</span><br><span class="line">        [forwardInv invoke];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class superCls = [[slf <span class="keyword">class</span>] superclass];</span><br><span class="line">        Method superForwardMethod = class_getInstanceMethod(superCls, <span class="keyword">@selector</span>(forwardInvocation:));</span><br><span class="line">        <span class="keyword">void</span> (*superForwardIMP)(<span class="keyword">id</span>, SEL, <span class="built_in">NSInvocation</span> *);</span><br><span class="line">        superForwardIMP = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSInvocation</span> *))method_getImplementation(superForwardMethod);</span><br><span class="line">        superForwardIMP(slf, <span class="keyword">@selector</span>(forwardInvocation:), invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JSPatch hook的函数执行逻辑：</p>
<blockquote>
<ul>
<li>4、当被Hook的方法执行时，会被转发到<code>JPForwardInvocation</code>函数中，该方法会把selectorName的前面拼接上”_JP”，在<code>_JSOverideMethods</code>中查找是否有该方法的JS代码，如果有，就进行参数解析，执行JS代码片段，最后再解析JS代码的返回值；</li>
<li>5、如果未找到，说明该方法并未被JSPatch所覆盖，应该调转到<code>JPExecuteORIGForwardInvocation</code>执行原有的转发</li>
<li>6、如果当前类响应<code>origForwardSelector</code>，则直接invoke执行；</li>
<li>7、否则，寻找父类的<code>forwardInvocation</code>方法，并invoke执行</li>
</ul>
</blockquote>
<p>用一张图表示下方法被JSPatch hook之后的状态<br><img src="/2018/01/24/iOS消息转发的正确Hook姿势/10.png" width="65%" height="65%"></p>
<h3 id="（2）Aspects的Hook原理"><a href="#（2）Aspects的Hook原理" class="headerlink" title="（2）Aspects的Hook原理"></a>（2）Aspects的Hook原理</h3><p>Aspects不光支持Hook类，还支持Hook对象，提供更小粒度的支持。对于对象的hook，<br>对于对象实例而言，Aspects并没有直接swizzling对象的<code>forwardInvocation</code> 方法，而是动态生成一个当前对象的子类，并将当前对象与子类关联，然后替换子类的 <code>forwardInvocation</code>方法，它的原理有些类似于KVO：将当前对象变成一个subclass 的实例，同时对于外部使用者而言，又能把它继续当成原对象在使用，而且所有的swizzling 操作都发生在子类，这样做的好处是你不需要去更改对象本身的类。但是Aspects的对象hook不在今天的讨论范围之内</p>
<p>我们主要讨论Aspects的类Hook<br>Aspects对于类的Hook与JSPatch的原理大同小异，核心代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> aspect_add(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    __block AspectIdentifier *identifier = <span class="literal">nil</span>;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="keyword">self</span>, selector, options, error)) &#123;</span><br><span class="line">            <span class="comment">// 给要Hook的类准备一个对应的AspectsContainer</span></span><br><span class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</span><br><span class="line">            <span class="comment">// 给要Hook的方法生成一个AspectIdentifier</span></span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="keyword">self</span> options:options block:block error:error];</span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                <span class="comment">// 将AspectIdentifier添加到AspectsContainer容器中</span></span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line">                <span class="comment">// Hook的核心方法，下面会展开</span></span><br><span class="line">                aspect_prepareClassAndHookSelector(<span class="keyword">self</span>, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_prepareClassAndHookSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="comment">// 完成类的forwardInvocation的Hook，对于每个要Hook的类，应该只走一次。具体实现参考aspect_swizzleForwardInvocation</span></span><br><span class="line">    Class klass = aspect_hookClass(<span class="keyword">self</span>, error);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据selector找到对应的Method</span></span><br><span class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</span><br><span class="line">    <span class="comment">// 找到方法的IMP</span></span><br><span class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</span><br><span class="line">    <span class="keyword">if</span> (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</span><br><span class="line">        <span class="keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">            <span class="comment">// 将SEL(aliasSelector)指向IMP(selector)</span></span><br><span class="line">            __unused <span class="built_in">BOOL</span> addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将SEL(selector)指向IMP(forwardInvocation)</span></span><br><span class="line">        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(<span class="keyword">self</span>, selector), typeEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</span><br><span class="line">    <span class="comment">// 如果没有method，replace实际上会像是class_addMethod一样</span></span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="string">"v@:@"</span>);</span><br><span class="line">    <span class="keyword">if</span> (originalImplementation) &#123;</span><br><span class="line">        <span class="comment">// 添加AspectsForwardInvocationSelectorName的方法，IMP为原生 forwardInvocation:</span></span><br><span class="line">        class_addMethod(klass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), originalImplementation, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ASPECTS_ARE_BEING_CALLED__(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSInvocation</span> *invocation) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(invocation);</span><br><span class="line">    SEL originalSelector = invocation.selector;</span><br><span class="line">    SEL aliasSelector = aspect_aliasForSelector(invocation.selector);</span><br><span class="line">    invocation.selector = aliasSelector;</span><br><span class="line">    AspectsContainer *objectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector);</span><br><span class="line">    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(<span class="keyword">self</span>), aliasSelector);</span><br><span class="line">    AspectInfo *info = [[AspectInfo alloc] initWithInstance:<span class="keyword">self</span> invocation:invocation];</span><br><span class="line">    <span class="built_in">NSArray</span> *aspectsToRemove = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instead hooks.</span></span><br><span class="line">    <span class="built_in">BOOL</span> respondsToAlias = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;</span><br><span class="line">        aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">        aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Class klass = object_getClass(invocation.target);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">                [invocation invoke];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到对应的hooks，调用原有的转发（通常抛出异常）</span></span><br><span class="line">    <span class="keyword">if</span> (!respondsToAlias) &#123;</span><br><span class="line">        invocation.selector = originalSelector;</span><br><span class="line">        SEL originalForwardInvocationSEL = <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">            ((<span class="keyword">void</span>( *)(<span class="keyword">id</span>, SEL, <span class="built_in">NSInvocation</span> *))objc_msgSend)(<span class="keyword">self</span>, originalForwardInvocationSEL, invocation);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove any hooks that are queued for deregistration.</span></span><br><span class="line">    [aspectsToRemove makeObjectsPerformSelector:<span class="keyword">@selector</span>(remove)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一张图表示下方法被Aspect hook之后的状态<br><img src="/2018/01/24/iOS消息转发的正确Hook姿势/11.png" width="65%" height="65%"></p>
<h2 id="JSPatch和Aspects的Hook混战"><a href="#JSPatch和Aspects的Hook混战" class="headerlink" title="JSPatch和Aspects的Hook混战"></a>JSPatch和Aspects的Hook混战</h2><p>如果项目中接入的第三方库，同时有多个库对类的forwardInvocation函数进行了Hook，那么就可能会引发各种各样的问题，接下来以Aspects和JSPatch为例，看看它俩直间的碰撞</p>
<p>先来点上下文</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyClass origin log"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)aspects_hook_test &#123;</span><br><span class="line">    [MyClass aspect_hookSelector:<span class="keyword">@selector</span>(test)</span><br><span class="line">                     withOptions:AspectPositionInstead</span><br><span class="line">                      usingBlock:^(<span class="keyword">id</span> aspects) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"aspects log"</span>);</span><br><span class="line">    &#125; error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defineClass(<span class="string">'MyClass'</span>, &#123;</span><br><span class="line">            test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"jspatch log"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>先总结下遇到的问题</p>
<table>
<thead>
<tr>
<th>操作</th>
<th style="text-align:right">结果   </th>
</tr>
</thead>
<tbody>
<tr>
<td>JSPatch先hook，Aspects再hook</td>
<td style="text-align:right">aspects log</td>
</tr>
<tr>
<td>Aspects先hook，JSPatch再hook</td>
<td style="text-align:right">jspatch log</td>
</tr>
<tr>
<td>Aspects先hook，JSPatch再hook，且JSpatch调用了self.ORIGxxx()</td>
<td style="text-align:right">crash</td>
</tr>
<tr>
<td>Aspects先hook父类一方法，JSPatch再hook子类同一方法，且JSPatch调用了self.super().xxx()</td>
<td style="text-align:right">crash</td>
</tr>
<tr>
<td>JSPatch先hook父类方法，Aspects再hook子类方法，然后调用[subclass superTest]</td>
<td style="text-align:right">crash</td>
</tr>
</tbody>
</table>
<p>接下来我们逐步分析：</p>
<h3 id="原始状态"><a href="#原始状态" class="headerlink" title="原始状态"></a>原始状态</h3><p>在没有任何hook动作之前，每个类的SEL和IMP的指向关系如下：<br><img src="/2018/01/24/iOS消息转发的正确Hook姿势/02.png" width="65%" height="65%"></p>
<h3 id="JSPatch-hook"><a href="#JSPatch-hook" class="headerlink" title="JSPatch hook"></a>JSPatch hook</h3><p>JSPatch的hook之后，类的SEL和IMP的指向示意图如下：<br><img src="/2018/01/24/iOS消息转发的正确Hook姿势/03.png" width="65%" height="65%"></p>
<h3 id="Aspects-hook"><a href="#Aspects-hook" class="headerlink" title="Aspects hook"></a>Aspects hook</h3><p>Aspects的hook之后，类的SEL和IMP的指向示意图如下：<br><img src="/2018/01/24/iOS消息转发的正确Hook姿势/04.png" width="65%" height="65%"></p>
<h3 id="JSPatch先hook，Aspects再hook"><a href="#JSPatch先hook，Aspects再hook" class="headerlink" title="JSPatch先hook，Aspects再hook"></a>JSPatch先hook，Aspects再hook</h3><p>JSPatch先hook函数test，Aspects在此基础上再对test进行hook，之后类的SEL和IMP的指向示意图如下：（注：这个时候不可避免地存在覆盖问题）<br><img src="/2018/01/24/iOS消息转发的正确Hook姿势/05.png" width="65%" height="65%"><br>如果此时向test方法发消息，根据①的指向，理所当然会进行转发，由于此时的<code>SEL(forwardInvocation)</code>指向了<code>IMP(__ASPECTS_ARE_BEING_CALLED__)</code>，所以转发会走到<code>__ASPECTS_ARE_BEING_CALLED__</code>函数中，由于此时能找到test对应的替换block，所以就会执行该block，输出<code>aspects log</code>，原先JSPatch的hook的JS代码片被覆盖，执行不到。</p>
<h3 id="Aspects先hook，JSPatch再hook"><a href="#Aspects先hook，JSPatch再hook" class="headerlink" title="Aspects先hook，JSPatch再hook"></a>Aspects先hook，JSPatch再hook</h3><p><img src="/2018/01/24/iOS消息转发的正确Hook姿势/06.png" width="65%" height="65%"><br>如果此时向test方法发消息，根据①的指向，理所当然会进行转发，由于此时的<code>SEL(forwardInvocation)</code>指向了<code>IMP(JPforwardInvocation)</code>，所以转发会走到<code>JPforwardInvocation</code>函数中，由于此时能找到test对应的JS代码块，所以就会执行该JS代码块，输出<code>jspatch log</code>，原先Aspects的hook的block被覆盖，执行不到。</p>
<h3 id="Aspects先hook，JSPatch再hook，且JSpatch调用了self-ORIGtest-，会发生crash"><a href="#Aspects先hook，JSPatch再hook，且JSpatch调用了self-ORIGtest-，会发生crash" class="headerlink" title="Aspects先hook，JSPatch再hook，且JSpatch调用了self.ORIGtest()，会发生crash"></a>Aspects先hook，JSPatch再hook，且JSpatch调用了self.ORIGtest()，会发生crash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JPAndAspects[70095:30054488] -[MyClass ORIGtest]: unrecognized selector sent to instance 0x60400001fa30</span><br><span class="line">JPAndAspects[70095:30054488] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;</span><br><span class="line">reason: &apos;-[MyClass ORIGtest]: unrecognized selector sent to instance 0x60400001fa30&apos;</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">    0   CoreFoundation                      0x00000001074dd1ab __exceptionPreprocess + 171</span><br><span class="line">    1   libobjc.A.dylib                     0x0000000106b7af41 objc_exception_throw + 48</span><br><span class="line">    2   CoreFoundation                      0x000000010755da34 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132</span><br><span class="line">    3   JPAndAspects                        0x000000010524cd01 __ASPECTS_ARE_BEING_CALLED__ + 6129</span><br><span class="line">    4   CoreFoundation                      0x000000010746149c __invoking___ + 140</span><br><span class="line">    5   CoreFoundation                      0x0000000107461370 -[NSInvocation invoke] + 320</span><br><span class="line">    6   JPAndAspects                        0x000000010526ba4d JPExecuteORIGForwardInvocation + 429</span><br><span class="line">    7   JPAndAspects                        0x000000010525d38a JPForwardInvocation + 666</span><br><span class="line">    8   CoreFoundation                      0x000000010745fe08 ___forwarding___ + 760</span><br><span class="line">    9   CoreFoundation                      0x000000010745fa88 _CF_forwarding_prep_0 + 120</span><br></pre></td></tr></table></figure>
<p><img src="/2018/01/24/iOS消息转发的正确Hook姿势/06.png" width="75%" height="75%"><br>JSPatch hook的代码片如下所示，调用了self.ORIGtest()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineClass(<span class="string">'MyClass'</span>, &#123;</span><br><span class="line">            test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"jspatch log"</span>);</span><br><span class="line">            self.ORIGtest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果此时向test方法发消息，这个时候则会crash，为什么会crash呢？我们来分析一下：</p>
<blockquote>
<ul>
<li>根据①的指向，理所当然会进行转发，由于此时的<code>SEL(forwardInvocation)</code>指向了<code>IMP(JPforwardInvocation)</code>，所以转发会走到<code>JPforwardInvocation</code>函数中，由于此时能找到test对应的JS代码块，所以就会执行该JS代码块。</li>
<li>在JS代码片总调用了<code>self.ORIGtest()</code>，然而因为覆盖的原因，<code>SEL(ORIGtest)</code>不再指向<code>IMP(test)</code>，而是指向了<code>IMP(_objc_msgForward)</code>，毫无疑问会被转发到<code>IMP(JPforwardInvocation)</code>中，</li>
<li>但是此时并不能找到与<code>_JPORIGtest</code>对应的JS代码块，所以会走相对于JSPatch原有的转发<code>SEL(ORIGforwardInvocation)</code>，然而此时原有的转发SEL(ORIGforwardInvocation)由于覆盖的原因，被指向了<code>IMP(__ASPECTS_ARE_BEING_CALLED__)</code>，所以必然会走到函数<code>__ASPECTS_ARE_BEING_CALLED__</code>中。</li>
<li>在函数<code>__ASPECTS_ARE_BEING_CALLED__</code>中，仍然不可能找到<code>SEL(aspects__ORIGtest)</code>对应的block，所以会继续走相对于Aspects的原有转发<code>SEL(__aspects_forwardInvocation)</code>，因为<code>SEL(__aspects_forwardInvocation)</code>指向了<code>IMP(forwardInvocation)</code></li>
<li>本例中我们并没有实现<code>IMP(forwardInvocation)</code>，所以会crash，即使我们做了实现，也仍然不可能会预料到会有这样的<code>SEL(aspects__ORIGtest)</code>，所以也必然会crash。</li>
</ul>
</blockquote>
<p>那么这个问题怎么解决呢？<br><strong>理论上，ORIGtest作为函数原有的实现，不应该走到转发里面，它应该是直接指向IMP(test)。然而一旦走到JPforwardInvocation里面，说明类的test方法已经被其它的库提前hook掉了。我们需要考虑当前的ORIGtest是否已经被hook，如果未hook，需要走原有的流程，如果已经被hook，需要去掉ORIG，再进行转发</strong></p>
<p>修改JSPatch源代码，在函数<code>JPForwardInvocation</code>中，查不到对应到JS代码块并走原有转发之前，添加如下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!jsFunc) &#123;</span><br><span class="line">        <span class="comment">// 添加的代码</span></span><br><span class="line">        IMP invocationIMP = class_getMethodImplementation([slf <span class="keyword">class</span>], invocation.selector);</span><br><span class="line">        <span class="keyword">if</span>([selectorName hasPrefix:<span class="string">@"ORIG"</span>] &amp;&amp; (invocationIMP == _objc_msgForward || invocationIMP==_objc_msgForward_stret))</span><br><span class="line">        &#123;</span><br><span class="line">            selectorName = [selectorName stringByReplacingOccurrencesOfString:<span class="string">@"ORIG"</span> withString:<span class="string">@""</span>];</span><br><span class="line">            invocation.selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走原有的转发</span></span><br><span class="line">        JPExecuteORIGForwardInvocation(slf, selector, invocation);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JPAndAspects[70724:30115450] JSPatch.log: jspatch log</span><br><span class="line">JPAndAspects[70724:30115450] aspects log</span><br></pre></td></tr></table></figure></p>
<h3 id="Aspects先hook父类test方法，JSPatch再hook子类同一方法，且JSPatch调用了self-super-xxx"><a href="#Aspects先hook父类test方法，JSPatch再hook子类同一方法，且JSPatch调用了self-super-xxx" class="headerlink" title="Aspects先hook父类test方法，JSPatch再hook子类同一方法，且JSPatch调用了self.super().xxx()"></a>Aspects先hook父类test方法，JSPatch再hook子类同一方法，且JSPatch调用了self.super().xxx()</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyClass origin log"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MySubClass</span> : <span class="title">MyClass</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MySubClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MySubClass origin log"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)aspects_hook_test &#123;</span><br><span class="line">    [MyClass aspect_hookSelector:<span class="keyword">@selector</span>(test)</span><br><span class="line">                     withOptions:AspectPositionInstead</span><br><span class="line">                      usingBlock:^(<span class="keyword">id</span> aspects) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"MyClass aspects log"</span>);</span><br><span class="line">    &#125; error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineClass(<span class="string">'MySubClass'</span>, &#123;</span><br><span class="line">            test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"MySubClass jspatch log"</span>);</span><br><span class="line">            self.super().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果此时向<code>MySubClass</code>的一个实例对象的test方法发送消息，则会crash<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JPAndAspects[73431:30359622] JSPatch.log: MySubClass jspatch log</span><br><span class="line">JPAndAspects[73431:30359622] -[MySubClass SUPER_test]: unrecognized selector sent to instance 0x608000017220</span><br><span class="line">JPAndAspects[73431:30359622] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;</span><br><span class="line">reason: &apos;-[MySubClass SUPER_test]: unrecognized selector sent to instance 0x608000017220&apos;</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">    0   CoreFoundation                      0x00000001044cf1ab __exceptionPreprocess + 171</span><br><span class="line">    1   libobjc.A.dylib                     0x0000000103b64f41 objc_exception_throw + 48</span><br><span class="line">    2   CoreFoundation                      0x000000010454fa34 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132</span><br><span class="line">    3   JPAndAspects                        0x0000000102733da1 __ASPECTS_ARE_BEING_CALLED__ + 6129</span><br><span class="line">    4   JPAndAspects                        0x0000000102752b81 JPExecuteORIGForwardInvocation + 577</span><br><span class="line">    5   JPAndAspects                        0x000000010274442a JPForwardInvocation + 666</span><br><span class="line">    6   CoreFoundation                      0x0000000104451e08 ___forwarding___ + 760</span><br><span class="line">    7   CoreFoundation                      0x0000000104451a88 _CF_forwarding_prep_0 + 120</span><br></pre></td></tr></table></figure></p>
<p>我们先来看下hook后的状态信息<br><img src="/2018/01/24/iOS消息转发的正确Hook姿势/07.png"><br>为什么会crash呢？我们来分析一下：</p>
<blockquote>
<ul>
<li>1、根据⑥的指向，如果向子类<code>MySubClass</code>的一个实例对象的test方法发送消息，则会走向转发，根据⑨的指向，此时<code>MySubClass</code>的<code>SEL(forwardInvocation)</code>指向了<code>IMP(JPforwardInvocation)</code>，肯定会转发到方法<code>JPforwardInvocation</code>中；</li>
<li>2、由于此时能找到test对应的JS代码块，所以就会执行该JS代码块，输出<code>MySubClass jspatch log</code>，由于JS代码块状中执行了<code>self.super().test()</code>，由于JSPatch的super的实现原理是：<strong>如果是调用super方法，找到superClass这个方法的IMP实现，为当前类新增一个方法指向super的 IMP 实现，那么调用这个类的新方法就相当于调用super方法</strong>，所以调用<code>self.super().test()</code>时，JSPatch会给MySubClass添加一个SEL(SUPER_test)，指向父类MyClass的IMP(test)，并进行转发，很不幸的是父类的SEL(test)已经指向了IMP(_objc_msgForward)，所以SEL(_JPSUPER_test)也跟着指向了IMP(_objc_msgForward)；</li>
<li>3、根据⑨的指向，根据毫无疑问，会再次转发进入方法<code>JPforwardInvocation</code>中，此时因为找不到<code>SEL(_JPSUPER_test)</code>对应的JS代码块，所以会进行原有转发，进入方法<code>JPExecuteORIGForwardInvocation</code>中</li>
<li>4、由于子类<code>MySubClass</code>并没有对<code>forwardInvocation</code>转发函数做实现，所以会进入父类MyClass的转发中，根据④的指向，肯定会跑到<code>__ASPECTS_ARE_BEING_CALLED__</code>函数中，然而在这个函数中无法找到SEL(<code>aspects__SUPER_test</code>)对应的block，所以会直接crash；</li>
</ul>
</blockquote>
<p>那么如何解决这个问题呢？<br>这个问题与ORIG问题很相似，理论上，super的调用也不应该跑到自己的转发中，而是直接指向父类的实现。然而由于父类被Aspects提前hook，导致对<code>self.super().test()</code>的调用再次阴差阳错地进入到自己的转发中，于是就发生了后来的一切。。。</p>
<p>继续照葫芦画瓢，在找不到对应的JS代码块进入原有转发之前，判断selectorName是否包含<code>SUPER_</code>前缀，并且其指向的IMP已经被hook为<code>_objc_msgForward</code>，如果是，需要去掉<code>SUPER_</code>前缀，然后再进行转发。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!jsFunc) &#123;</span><br><span class="line">        IMP invocationIMP = class_getMethodImplementation([slf <span class="keyword">class</span>], invocation.selector);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>([selectorName hasPrefix:<span class="string">@"SUPER_"</span>] &amp;&amp; (invocationIMP == _objc_msgForward || invocationIMP==_objc_msgForward_stret))&#123;</span><br><span class="line">            selectorName = [selectorName stringByReplacingOccurrencesOfString:<span class="string">@"SUPER_"</span> withString:<span class="string">@""</span>];</span><br><span class="line">            invocation.selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        JPExecuteORIGForwardInvocation(slf, selector, invocation);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSPatch先hook父类方法，Aspects再hook子类方法，然后调用-subclass-superTest"><a href="#JSPatch先hook父类方法，Aspects再hook子类方法，然后调用-subclass-superTest" class="headerlink" title="JSPatch先hook父类方法，Aspects再hook子类方法，然后调用[subclass superTest]"></a>JSPatch先hook父类方法，Aspects再hook子类方法，然后调用[subclass superTest]</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)superTest;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">-(<span class="keyword">void</span>)superTest&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyClass superTest"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MySubClass</span> : <span class="title">MyClass</span></span></span><br><span class="line">-(<span class="keyword">void</span>)subTest;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MySubClass</span></span></span><br><span class="line">-(<span class="keyword">void</span>)subTest&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MySubClass subTest"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defineClass(<span class="string">'MyClass'</span>, &#123;</span><br><span class="line">            superTest: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"MyClass superTest jspatch log"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[MySubClass aspect_hookSelector:<span class="keyword">@selector</span>(subTest)</span><br><span class="line">                     withOptions:AspectPositionInstead</span><br><span class="line">                      usingBlock:^(<span class="keyword">id</span> aspects) &#123;</span><br><span class="line">                          <span class="built_in">NSLog</span>(<span class="string">@"MySubClass subTest aspects log"</span>);</span><br><span class="line">                          </span><br><span class="line">                      &#125; error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JPAndAspects[76443:30659220] -[MySubClass superTest]: unrecognized selector sent to instance 0x600000016d10</span><br><span class="line">JPAndAspects[76443:30659220] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, </span><br><span class="line">reason: &apos;-[MySubClass superTest]: unrecognized selector sent to instance 0x600000016d10&apos;</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">    0   CoreFoundation                      0x00000001029071ab __exceptionPreprocess + 171</span><br><span class="line">    1   libobjc.A.dylib                     0x0000000101f9cf41 objc_exception_throw + 48</span><br><span class="line">    2   CoreFoundation                      0x0000000102987a34 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132</span><br><span class="line">    3   JPAndAspects                        0x0000000100b6bcb1 __ASPECTS_ARE_BEING_CALLED__ + 6129</span><br><span class="line">    4   CoreFoundation                      0x0000000102889e08 ___forwarding___ + 760</span><br><span class="line">    5   CoreFoundation                      0x0000000102889a88 _CF_forwarding_prep_0 + 120</span><br></pre></td></tr></table></figure>
<p>我们先来看下hook后的状态信息<br><img src="/2018/01/24/iOS消息转发的正确Hook姿势/08.png"></p>
<p>我们来分析下为什么会crash：</p>
<blockquote>
<ul>
<li>1、根据①的指向，由于父类MyClass的<code>SEL(superTest)</code>指向了<code>IMP(_objc_msgForward)</code>，所以在调用<code>[subclass superTest]</code>，肯定会发生转发；</li>
<li>2、由于子类MySubClass的<code>SEL(forwardInvocation)</code>指向了<code>IMP(__ASPECTS_ARE_BEGIN_CALLED__)</code>，所以肯定会跑到<code>__ASPECTS_ARE_BEGIN_CALLED__</code>函数中；</li>
<li>3、由于在子类的<code>__ASPECTS_ARE_BEGIN_CALLED__</code>中找不到<code>SEL(aspects__superTest)</code>对应的block，所以会认为没有hook，走原有的转发；</li>
<li>4、由于子类本身<code>SEL(__aspects_forwardInvocation)</code>指向的<code>IMP(forwardInvocation)</code>并没有实现，所有直接crash。</li>
</ul>
</blockquote>
<p>那么如何解决呢？<br>这个问题的本质原因是子类的处理不了<code>SEL(aspects__superTest)</code>，同时又无法让真正可以处理的父类的forwardInvocation来处理，换句话说， forwardInvocation的继承被父类的hook和子类的hook打断了。所以解决的方案就是想办法让继承层级来处理。<br>修改Aspect源代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="keyword">if</span> (!respondsToAlias) &#123;</span><br><span class="line">    invocation.selector = originalSelector;</span><br><span class="line">    SEL originalForwardInvocationSEL = <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>( *)(<span class="keyword">id</span>, SEL, <span class="built_in">NSInvocation</span> *))objc_msgSend)(<span class="keyword">self</span>, originalForwardInvocationSEL, invocation);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="keyword">if</span> (!respondsToAlias) &#123;</span><br><span class="line">    invocation.selector = originalSelector;</span><br><span class="line">    SEL originalForwardInvocationSEL = <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);</span><br><span class="line">    SEL forwardInvocationSEL = <span class="keyword">@selector</span>(forwardInvocation:);</span><br><span class="line">    Class kClass = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    Method method = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        method = class_getInstanceMethod(kClass, originalForwardInvocationSEL) ?:</span><br><span class="line">        class_getInstanceMethod(kClass, forwardInvocationSEL);</span><br><span class="line">        FORWARD_INVOCATION_IMP imp = method ? (FORWARD_INVOCATION_IMP)method_getImplementation(method) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(imp &amp;&amp; (imp != &amp;__ASPECTS_ARE_BEING_CALLED__))&#123;</span><br><span class="line">            imp(<span class="keyword">self</span>,<span class="keyword">@selector</span>(forwardInvocation:),invocation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>((kClass = class_getSuperclass(kClass)));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == method)&#123;</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改后的运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JPAndAspects[78567:30830810] JSPatch.log: MyClass superTest jspatch log</span><br></pre></td></tr></table></figure></p>
<h2 id="如何保持正确的Hook姿势？"><a href="#如何保持正确的Hook姿势？" class="headerlink" title="如何保持正确的Hook姿势？"></a>如何保持正确的Hook姿势？</h2><p>到目前为止，我们分析了JSPatch和Aspects同时hook消息转发forwardInvocation带来的一些问题，并逐个分析给出了解决方案，<strong>解决的核心就是要找到多个库hook之后的转发状态，从中分析方法的调用流程。</strong></p>
<p>前面的混战虽然只涉及到两个库，但是其中的复杂性还是相当复杂，相信读到这里的您一定也有体会。然而这仅仅是2个库的混战，倘若有多个库呢？每个库的hook逻辑往往只考虑到了自己，认为项目中只有自己在使用黑魔法，殊不知别的库也是这么想的，由于这些库的hook肯定有前后顺序，所以必然存在逻辑覆盖或者诡异的转发跳跃，进而导致了各种各样的crash和逻辑异常:</p>
<blockquote>
<ul>
<li>1、crash肯定是我们最不想要的，所以要分析，要解决，要避免；</li>
<li>2、逻辑覆盖不一定会crash，但是对一个类同时用了好几种hook库，这种产品逻辑或者技术逻辑是否有一定的问题呢？</li>
<li>3、多个库hook出现问题的一个根本原因就是：每个库都认为自己hook之前，<code>SEL(forwardInvocation)</code>指向的是原有的转发<code>IMP(forwardInvocation)</code>，殊不知在这之前其他的库捷足先登，已经将<code>SEL(forwardInvocation)</code>指向了别的实现，而原来的转发实现对于当前库已经找不到了，从而导致了错误的原有转发，发生crash。如果我们实现一个获取原有转发的机制，不再依赖hook前的状态，可以解决这个问题。不过即使如此，也无法避免<code>SEL(forwardInvocation)</code>的指向发生逻辑覆盖，某种程度上，这个问题估计也是无解。倘若接入的库是闭源的，情况会更加严重！<br>所以当我们实现这样的库，或者接入这样的库，要格外小心，谨慎应对他们带来的坑！</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>转发有风险，hook需谨慎</p>

      
    </div>
    
    
    

    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束 感谢您的阅读-------------</div>
    
</div>

      <div>
    

    
      <div>
        
<div class="my_post_copyright">
  <script src="//s0.pstatp.com/cdn/expire-1-M/clipboard.js/1.5.10/clipboard.min.js"></script>
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://s1.pstatp.com/cdn/expire-1-M/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2018/01/24/iOS消息转发的正确Hook姿势/">JSPatch VS Aspects</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 lingyun 的个人博客">lingyun</a></p>
  <p><span>发布时间:</span>2018年01月24日 - 22:01</p>
  <p><span>最后更新:</span>2018年05月30日 - 22:05</p>
  <p><span>原始链接:</span><a href="/2018/01/24/iOS消息转发的正确Hook姿势/" title="JSPatch VS Aspects">https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
  });
    });  
</script>


      <div>
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="lingyun 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="lingyun 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        
<div class="my_post_copyright">
  <script src="//s0.pstatp.com/cdn/expire-1-M/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://s1.pstatp.com/cdn/expire-1-M/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2018/01/24/iOS消息转发的正确Hook姿势/">JSPatch VS Aspects</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 lingyun 的个人博客">lingyun</a></p>
  <p><span>发布时间:</span>2018年01月24日 - 22:01</p>
  <p><span>最后更新:</span>2018年05月30日 - 22:05</p>
  <p><span>原始链接:</span><a href="/2018/01/24/iOS消息转发的正确Hook姿势/" title="JSPatch VS Aspects">https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://tsuijunxi.github.io/2018/01/24/iOS消息转发的正确Hook姿势/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
  });
    });  
</script>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JSPatch/" rel="tag"># JSPatch</a>
          
            <a href="/tags/Aspects/" rel="tag"># Aspects</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/21/JSPatch的dealloc忧伤/" rel="next" title="JSPatch的dealloc忧伤">
                <i class="fa fa-chevron-left"></i> JSPatch的dealloc忧伤
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/28/iPhoneX适配之Home-Indicator/" rel="prev" title="iPhoneX适配之Home-Indicator">
                iPhoneX适配之Home-Indicator <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/favicon.ico"
                alt="lingyun" />
            
              <p class="site-author-name" itemprop="name">lingyun</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry, Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS的消息转发机制"><span class="nav-number">2.</span> <span class="nav-text">iOS的消息转发机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS消息转发机制的Hook原理"><span class="nav-number">3.</span> <span class="nav-text">iOS消息转发机制的Hook原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）JSPatch的Hook原理"><span class="nav-number">3.1.</span> <span class="nav-text">（1）JSPatch的Hook原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）Aspects的Hook原理"><span class="nav-number">3.2.</span> <span class="nav-text">（2）Aspects的Hook原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSPatch和Aspects的Hook混战"><span class="nav-number">4.</span> <span class="nav-text">JSPatch和Aspects的Hook混战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原始状态"><span class="nav-number">4.1.</span> <span class="nav-text">原始状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSPatch-hook"><span class="nav-number">4.2.</span> <span class="nav-text">JSPatch hook</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aspects-hook"><span class="nav-number">4.3.</span> <span class="nav-text">Aspects hook</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSPatch先hook，Aspects再hook"><span class="nav-number">4.4.</span> <span class="nav-text">JSPatch先hook，Aspects再hook</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aspects先hook，JSPatch再hook"><span class="nav-number">4.5.</span> <span class="nav-text">Aspects先hook，JSPatch再hook</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aspects先hook，JSPatch再hook，且JSpatch调用了self-ORIGtest-，会发生crash"><span class="nav-number">4.6.</span> <span class="nav-text">Aspects先hook，JSPatch再hook，且JSpatch调用了self.ORIGtest()，会发生crash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aspects先hook父类test方法，JSPatch再hook子类同一方法，且JSPatch调用了self-super-xxx"><span class="nav-number">4.7.</span> <span class="nav-text">Aspects先hook父类test方法，JSPatch再hook子类同一方法，且JSPatch调用了self.super().xxx()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSPatch先hook父类方法，Aspects再hook子类方法，然后调用-subclass-superTest"><span class="nav-number">4.8.</span> <span class="nav-text">JSPatch先hook父类方法，Aspects再hook子类方法，然后调用[subclass superTest]</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何保持正确的Hook姿势？"><span class="nav-number">5.</span> <span class="nav-text">如何保持正确的Hook姿势？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lingyun</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">133.0k</span>

  <div class="powered-by">
    <i class="fa fa-user-md"></i>
    <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>|
    <i class="fa fa-eye-md"></i>
    <span id="busuanzi_container_site_uv">
      本站访客数:<span id="busuanzi_value_site_uv"></span>人
    </span>

  </div>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="/js/src/md5.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '3b98a5ec68bfccc21c29',
          clientSecret: '4c30086ddf0fdf77d050830b540bcffd3054c1b0',
          repo: 'tsuijunxi.github.io',
          owner: 'tsuijunxi',
          admin: ['tsuijunxi'], 
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>


  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
